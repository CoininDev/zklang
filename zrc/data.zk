// these are the data types in ZK:


struct Struct {
  string name;
}

// generics
struct Struct<T> {
  T variable;
}

enum Maybe<T> {
  Just{t: T};
  Nothing;
}

// pattern matching
fn pattern_match() {
  let maybe = Maybe.Just{string "val"};
  match(maybe) {
    Just{s: string} => {
      // do something
    }
    Nothing => {
      // do another thing
    }
  }
  // Yes, I just copied Rust, enums and matches are some of the things Rust does well.
  // I am not ashamed of copying good implementation if needed.
}

// type matching
fn type_match() +IO {
  let maybe_s = Maybe.Just{string "mal"};
  let maybe_i = Maybe.Just{int 4};
  match(maybe_s) {
    Just(s: string) => s |> IO.println,
    Just(i: int) => i + i == 8 |> IO.println,
    Just(v) => v |> typeof |> IO.println,
    Nothing => {}
  }

  let struct_b = Struct{bool false};
  let struct_f = Struct{float 3.14};
  let struct_m = Struct{Maybe.Just(string "Just")};

  match(struct_f) {
    <bool> => {
      if (variable) IO.println("Hello :3");
    },
    <string> => variable|> IO.println,
  }
}
